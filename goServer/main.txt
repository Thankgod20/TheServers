package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/blocto/solana-go-sdk/common"
	"github.com/blocto/solana-go-sdk/program/metaplex/token_metadata"
	"github.com/gagliardetto/solana-go"
	"github.com/gagliardetto/solana-go/rpc"
	"github.com/go-redis/redis"
	"github.com/gorilla/websocket"
	holders "github.com/thankgod20/scraperServer/Holders"
	notity "github.com/thankgod20/scraperServer/Notification"
)

const (
	filePath_      = "extractedData.json"
	staticFolder   = "/static"
	tokenFolder    = "/spltoken"
	contentTypeKey = "Content-Type"
	contentTypeVal = "application/json"
)

// ----------------------
// Structures for Add-Address and Migration Events
// ----------------------

type NFTMetadata struct {
	Name   string `json:"name"`
	Symbol string `json:"symbol"`
	URI    string `json:"uri"`
}
type NullTime struct {
	time.Time
}
type Transfer struct {
	Address string   `json:"address"`
	Amount  float64  `json:"amount"`
	Time    NullTime `json:"time"`
	Price   float64  `json:"price"`
}

type Address struct {
	Address      string     `json:"address"`
	Name         string     `json:"name"`
	Symbol       string     `json:"symbol"`
	Index        int64      `json:"index"`
	AddedAt      *time.Time `json:"added_at"`
	LastActivity *time.Time `json:"last_activity"`
}
type Session struct {
	ID      int    `json:"id"`
	Port    int    `json:"port"`
	Status  string `json:"status"`
	Updated string `json:"updated"`
}
type Cookies struct {
	AuthToken string `json:"auth_token"`
	Ct0       string `json:"ct0"`
}
type Proxy struct {
	Address string `json:"proxies"`
}
type TokenMetadata struct {
	Name   string `json:"name"`
	Symbol string `json:"symbol"`
	URI    string `json:"uri"`
}

var ExcludeAddrs = make(map[string]bool)

// MigrationEvent represents the JSON payload for a migration event.
type MigrationEvent struct {
	Signature string `json:"signature"`
	Mint      string `json:"mint"`
	TxType    string `json:"txType"`
	Pool      string `json:"pool"`
}
type HolderData struct {
	Address string    `json:"address"`
	Price   float64   `json:"price"`
	Amount  []float64 `json:"amount"`
	Time    []string  `json:"time"`
}

type TokenData struct {
	Holders []HolderData `json:"holders"`
}

var RedisClient *redis.Client

func init() {
	RedisClient = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379", // Update with your Redis server address
		Password: "",               // Update with your Redis password, if any
		DB:       0,                // Default DB
	})

	// Test the connection
	_, err := RedisClient.Ping().Result()
	if err != nil {
		log.Fatalf("Failed to connect to Redis: %v", err)
	}
	fmt.Println("Connected to Redis!")
}

// API response structure
type APIResponse struct {
	Keys   []string      `json:"keys"`
	Values []interface{} `json:"values"`
}

// ----------------------
// HTTP Handlers (Unchanged)
// ----------------------

func fetchHolderKeysAndDataHandler(w http.ResponseWriter, r *http.Request) {
	searchWord := r.URL.Query().Get("search")
	pattern := fmt.Sprintf("%s", searchWord)
	fmt.Println("Partern", pattern)

	client := holders.NewBitqueryClient()

	output, err := client.UpdateAndGetTransfers(pattern)
	if err != nil {
		log.Fatalf("Error updating and getting transfers: %v", err)
	}
	var transfers []Transfer
	if err := json.Unmarshal([]byte(output), &transfers); err != nil {
		log.Fatalf("Error decoding transfers: %v", err)
	}
	if len(transfers) == 0 {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "No matching keys found"})
		return
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(transfers); err != nil {
		http.Error(w, fmt.Sprintf("Failed to encode response: %v", err), http.StatusInternalServerError)
	}
}

func fetchKeysAndDataHandler(w http.ResponseWriter, r *http.Request) {
	searchWord := r.URL.Query().Get("search")
	pattern := fmt.Sprintf("*spltoken:%s*", searchWord)

	keys, err := RedisClient.Keys(pattern).Result()
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to retrieve keys: %v", err), http.StatusInternalServerError)
		return
	}

	var values []interface{}
	for _, key := range keys {
		value, err := RedisClient.Get(key).Result()
		if err != nil {
			log.Printf("Error retrieving value for key %s: %v", key, err)
			continue
		}
		var rawValue interface{}
		if err := json.Unmarshal([]byte(value), &rawValue); err == nil {
			values = append(values, rawValue)
		} else {
			cleanedValue := strings.ReplaceAll(value, "\\\"", "\"")
			values = append(values, cleanedValue)
		}
	}

	if len(values) == 0 {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"message": "No matching keys found"})
		return
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(values); err != nil {
		http.Error(w, fmt.Sprintf("Failed to encode response: %v", err), http.StatusInternalServerError)
	}
}

func getTokenMetadata(w http.ResponseWriter, r *http.Request) {
	mintAddress := r.URL.Query().Get("mint")
	if mintAddress == "" {
		http.Error(w, "Missing 'mint' query parameter", http.StatusBadRequest)
		return
	}
	mintPubKey, err := solana.PublicKeyFromBase58(mintAddress)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid mint address: %v", err), http.StatusBadRequest)
		return
	}
	client := rpc.New(rpc.MainNetBeta_RPC)
	commonMintPubKey := common.PublicKeyFromBytes(mintPubKey.Bytes())
	metadataPubKey, err := token_metadata.GetTokenMetaPubkey(commonMintPubKey)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to derive metadata public key: %v", err), http.StatusInternalServerError)
		return
	}
	accountInfo, err := client.GetAccountInfo(context.Background(), solana.PublicKeyFromBytes(metadataPubKey[:]))
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to fetch account info: %v", err), http.StatusInternalServerError)
		return
	}
	if accountInfo == nil || accountInfo.Value == nil {
		http.Error(w, "Metadata account not found", http.StatusNotFound)
		return
	}
	data := accountInfo.Value.Data.GetBinary()
	if data == nil {
		http.Error(w, "Failed to retrieve binary data from account info", http.StatusInternalServerError)
		return
	}
	metadata, err := token_metadata.MetadataDeserialize(data)
	if err != nil {
		http.Error(w, fmt.Sprintf("Failed to deserialize metadata: %v", err), http.StatusInternalServerError)
		return
	}

	response := NFTMetadata{
		Name:   metadata.Data.Name,
		Symbol: metadata.Data.Symbol,
		URI:    metadata.Data.Uri,
	}
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, fmt.Sprintf("Failed to encode response: %v", err), http.StatusInternalServerError)
	}
}

func saveDataHandler(w http.ResponseWriter, r *http.Request) {
	setHeaders(w)
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	var newData map[string]map[string]interface{}
	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()
	fmt.Println("Raw body:", string(body))
	if err := json.Unmarshal(body, &newData); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}
	rootDir := ensureFolder(staticFolder)
	existingData := make(map[string]map[string]interface{})
	filePath := filepath.Join(rootDir, filePath_)
	if _, err := os.Stat(filePath); err == nil {
		data, err := ioutil.ReadFile(filePath)
		if err == nil {
			json.Unmarshal(data, &existingData)
		}
	}
	for tokenAddress, tokenData := range newData {
		if _, exists := existingData[tokenAddress]; !exists {
			existingData[tokenAddress] = tokenData
		}
	}
	data, _ := json.MarshalIndent(existingData, "", "  ")
	if err := ioutil.WriteFile(filePath, data, 0644); err != nil {
		http.Error(w, "Error saving data", http.StatusInternalServerError)
		return
	}

	w.Write([]byte("Data saved successfully"))
}

func tweetHandler(w http.ResponseWriter, r *http.Request) {
	setHeaders(w)
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()
	fmt.Println("Recieveing", string(body))
	var requestData map[string]map[string]interface{}
	if err := json.Unmarshal(body, &requestData); err != nil {
		http.Error(w, "Invalid JSON", http.StatusBadRequest)
		return
	}

	rootDir := ensureFolder(tokenFolder)
	for tweetURL, data := range requestData {
		address := fmt.Sprintf("%v", data["address"])
		if address == "" {
			continue
		}
		filePath := filepath.Join(rootDir, address+".json")
		var fileData map[string]interface{}
		if _, err := os.Stat(filePath); err == nil {
			fileContent, _ := ioutil.ReadFile(filePath)
			json.Unmarshal(fileContent, &fileData)
		} else {
			fileData = make(map[string]interface{})
		}
		tweetContent, ok := data["tweet"].(string)
		if !ok || tweetContent == "" {
			fmt.Println("Missing or invalid tweet content")
			continue
		}
		if _, exists := fileData[tweetURL]; !exists {
			fileData[tweetURL] = map[string]interface{}{
				"tweetData": map[string]string{
					"tweet": tweetContent,
				},
			}
			dataToWrite, _ := json.MarshalIndent(fileData, "", "  ")
			ioutil.WriteFile(filePath, dataToWrite, 0644)
		}
	}

	w.Write([]byte(`{"message": "Data processed successfully."}`))
}

func tweetURLHandler(w http.ResponseWriter, r *http.Request) {
	setHeaders(w)
	if r.Method != http.MethodPost {
		http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
		return
	}

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Unable to read request body", http.StatusInternalServerError)
		return
	}
	defer r.Body.Close()

	if strings.TrimSpace(string(body)) == "" {
		http.Error(w, "Request body is empty", http.StatusBadRequest)
		return
	}

	w.Write([]byte(`{"message": "Data saved successfully"}`))
}

func ensureFolder(folder string) string {
	rootDir := filepath.Join("..", folder)
	if err := os.MkdirAll(rootDir, os.ModePerm); err != nil {
		fmt.Println(err)
	}
	return rootDir
}

func contains(slice []string, item string) bool {
	for _, value := range slice {
		if value == item {
			return true
		}
	}
	return false
}

// ----------------------
// New Helper Function to Get Token Metadata via API
// ----------------------

func getTokenMetadataFromAPI(mint string) (*TokenMetadata, error) {
	url := fmt.Sprintf("http://localhost:3300/api/token-metadata?mint=%s", mint)
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch token metadata, status code: %d", resp.StatusCode)
	}
	var metadata TokenMetadata
	if err := json.NewDecoder(resp.Body).Decode(&metadata); err != nil {
		return nil, err
	}
	return &metadata, nil
}

// ----------------------
// WebSocket Migration Subscription and Address Update Logic
// ----------------------

// subscribeMigration connects to the WebSocket endpoint and subscribes for migration events.
func subscribeMigration() {
	wsURL := "wss://pumpportal.fun/api/data"
	conn, _, err := websocket.DefaultDialer.Dial(wsURL, nil)
	if err != nil {
		log.Println("WebSocket dial error:", err)
		return
	}
	defer conn.Close()
	log.Println("Connected to migration subscription at", wsURL)

	// Send subscription request for migration events.
	subscription := map[string]string{"method": "subscribeMigration"}
	msg, err := json.Marshal(subscription)
	if err != nil {
		log.Println("Error marshalling subscription:", err)
		return
	}

	if err = conn.WriteMessage(websocket.TextMessage, msg); err != nil {
		log.Println("Error sending subscription message:", err)
		return
	}
	log.Println("Sent migration subscription message.")

	// Continuously read messages.
	for {
		_, message, err := conn.ReadMessage()
		if err != nil {
			log.Println("Error reading message:", err)
			break
		}
		log.Println("Received migration event:", string(message))
		// Parse the incoming migration event.
		var event MigrationEvent
		err = json.Unmarshal(message, &event)
		if err != nil {
			log.Println("Error parsing migration event:", err)
			continue
		}
		// Only process if it is a migration event.
		if event.TxType == "migrate" {
			err = addMigratedTokenToAddresses(event)
			if err != nil {
				log.Println("Error adding migrated token to addresses:", err)
			} else {
				log.Println("Added migrated token", event.Mint, "to addresses")
			}
		}
	}
}

// addMigratedTokenToAddresses reads the current addresses file and appends the new token if not already present.
/*
func addMigratedTokenToAddresses(event MigrationEvent) error {
	addressesFile := filepath.Join("..", "addresses", "address.json")
	var addresses []Address
	if data, err := ioutil.ReadFile(addressesFile); err == nil {
		json.Unmarshal(data, &addresses)
	} else {
		addresses = []Address{}
	}
	if int64(len(addresses)) < 25 {
		// Check for duplicates.
		for _, addr := range addresses {
			if strings.EqualFold(addr.Address, event.Mint) {
				log.Println("Token already exists in addresses:", event.Mint)
				return nil
			}
		}

		// Fetch token metadata.
		metadata, err := getTokenMetadataFromAPI(event.Mint)
		if err != nil {
			log.Println("Failed to get metadata for", event.Mint, err)
			metadata = &TokenMetadata{Name: "", Symbol: "", URI: ""}
		}

		newIndex := int64(len(addresses))
		if newIndex > 4 {
			newIndex = int64(len(addresses)) % 5
		}
		// Record addition time
		now := time.Now().UTC()
		fmt.Println("Time Now", now)
		newAddress := Address{
			Address:      event.Mint,
			Name:         metadata.Name,
			Symbol:       metadata.Symbol,
			Index:        newIndex,
			AddedAt:      &now,
			LastActivity: &now,
		}
		addresses = append(addresses, newAddress)
		os.MkdirAll(filepath.Dir(addressesFile), os.ModePerm)
		file, err := os.Create(addressesFile)
		if err != nil {
			return err
		}
		defer file.Close()
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")

		return encoder.Encode(addresses)
	}
	return nil
}
*/

func addMigratedTokenToAddresses(event MigrationEvent) error {
	addressesFile := filepath.Join("..", "addresses", "address.json")
	var addresses []Address

	// Read existing addresses
	if data, err := ioutil.ReadFile(addressesFile); err == nil {
		json.Unmarshal(data, &addresses)
	} else {
		addresses = []Address{}
	}

	if int64(len(addresses)) < 500 {
		// Check for duplicates
		for _, addr := range addresses {
			if strings.EqualFold(addr.Address, event.Mint) {
				log.Println("Token already exists in addresses:", event.Mint)
				return nil
			}
		}

		// Fetch token metadata
		metadata, err := getTokenMetadataFromAPI(event.Mint)
		if err != nil {
			log.Println("Failed to get metadata for", event.Mint, err)
			metadata = &TokenMetadata{Name: "", Symbol: "", URI: ""}
		}

		newIndex := int64(len(addresses))
		if newIndex > 49 {
			newIndex = int64(len(addresses)) % 50
		}

		// Record addition time
		now := time.Now().UTC()
		newAddress := Address{
			Address:      event.Mint,
			Name:         metadata.Name,
			Symbol:       metadata.Symbol,
			Index:        newIndex,
			AddedAt:      &now,
			LastActivity: &now,
		}

		addresses = append(addresses, newAddress)
		os.MkdirAll(filepath.Dir(addressesFile), os.ModePerm)
		file, err := os.Create(addressesFile)
		if err != nil {
			return err
		}
		defer file.Close()
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")

		return encoder.Encode(addresses)
	}

	// If addresses are 25 or more, read activesession.json
	sessionsFile := filepath.Join("..", "datacenter", "activesession.json")
	data, err := ioutil.ReadFile(sessionsFile)
	if err != nil {
		return err
	}

	var sessions []Session
	if err := json.Unmarshal(data, &sessions); err != nil {
		return err
	}

	for _, session := range sessions {
		if strings.Contains(session.Status, "ArraySize") {
			arraySize, err := extractArraySize(session.Status)
			if err != nil {
				continue
			}

			if arraySize < 5 {
				// Fetch token metadata
				metadata, err := getTokenMetadataFromAPI(event.Mint)
				if err != nil {
					log.Println("Failed to get metadata for", event.Mint, err)
					metadata = &TokenMetadata{Name: "", Symbol: "", URI: ""}
				}

				// Record addition time
				now := time.Now().UTC()
				newAddress := Address{
					Address:      event.Mint,
					Name:         metadata.Name,
					Symbol:       metadata.Symbol,
					Index:        int64(session.ID),
					AddedAt:      &now,
					LastActivity: &now,
				}

				addresses = append(addresses, newAddress)
				os.MkdirAll(filepath.Dir(addressesFile), os.ModePerm)
				file, err := os.Create(addressesFile)
				if err != nil {
					return err
				}
				defer file.Close()
				encoder := json.NewEncoder(file)
				encoder.SetIndent("", "  ")

				return encoder.Encode(addresses)
			}
		}
	}

	return errors.New("no suitable session found to add the new address")
}

// Helper function to extract ArraySize value from status string
func extractArraySize(status string) (int, error) {
	re := regexp.MustCompile(`ArraySize\s+(\d+)`)
	matches := re.FindStringSubmatch(status)
	if len(matches) < 2 {
		return 0, errors.New("ArraySize not found in status")
	}
	var size int
	fmt.Sscanf(matches[1], "%d", &size)
	return size, nil
}

// ----------------------
// New Endpoints: Add Proxies, Cookies, and Addresses
// ----------------------

func addProxiesHandler(w http.ResponseWriter, r *http.Request) {
	outputPath := filepath.Join("..", "datacenter", "proxies.json")
	var proxies []Proxy
	if data, err := ioutil.ReadFile(outputPath); err == nil {
		json.Unmarshal(data, &proxies)
	}

	if r.Method == http.MethodPost {
		if err := r.ParseForm(); err != nil {
			http.Error(w, "Failed to parse form", http.StatusBadRequest)
			return
		}
		action := r.FormValue("action")
		switch action {
		case "add":
			newProxiesText := r.FormValue("newProxies")
			lines := strings.Split(newProxiesText, "\n")
			for _, line := range lines {
				line = strings.TrimSpace(line)
				if line != "" {
					proxies = append(proxies, Proxy{Address: line})
				}
			}
		case "edit":
			indexStr := r.FormValue("index")
			newProxyValue := strings.TrimSpace(r.FormValue("proxy"))
			index, err := strconv.Atoi(indexStr)
			if err == nil && index >= 0 && index < len(proxies) && newProxyValue != "" {
				proxies[index].Address = newProxyValue
			}
		case "delete":
			indexStr := r.FormValue("index")
			index, err := strconv.Atoi(indexStr)
			if err == nil && index >= 0 && index < len(proxies) {
				proxies = append(proxies[:index], proxies[index+1:]...)
			}
		default:
			http.Error(w, "Unknown action", http.StatusBadRequest)
			return
		}
		os.MkdirAll(filepath.Dir(outputPath), os.ModePerm)
		file, err := os.Create(outputPath)
		if err != nil {
			http.Error(w, "Error updating file", http.StatusInternalServerError)
			return
		}
		defer file.Close()
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(proxies); err != nil {
			http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
			return
		}
		http.Redirect(w, r, "/add-proxies", http.StatusSeeOther)
		return
	}

	w.Header().Set("Content-Type", "text/html")
	html := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Manage Proxies</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea { width: 100%; height: 100px; }
    input[type="text"] { width: 300px; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    form.inline { display: inline; }
    button { margin: 2px; }
  </style>
</head>
<body>
  <h1>Manage Proxies</h1>
  <h2>Add New Proxies</h2>
  <form method="POST" action="/add-proxies">
    <textarea name="newProxies" placeholder="Enter proxies, one per line (IP:PORT)"></textarea><br>
    <input type="hidden" name="action" value="add">
    <button type="submit">Add Proxies</button>
  </form>
  <h2>Current Proxies</h2>
  <table>
    <tr>
      <th>#</th>
      <th>Proxy</th>
      <th>Actions</th>
    </tr>`
	for i, proxy := range proxies {
		html += `<tr>
      <td>` + fmt.Sprintf("%d", i) + `</td>
      <td>
        <form method="POST" action="/add-proxies" class="inline">
          <input type="text" name="proxy" value="` + proxy.Address + `" required>
          <input type="hidden" name="index" value="` + fmt.Sprintf("%d", i) + `">
          <input type="hidden" name="action" value="edit">
          <button type="submit">Update</button>
        </form>
      </td>
      <td>
        <form method="POST" action="/add-proxies" class="inline">
          <input type="hidden" name="index" value="` + fmt.Sprintf("%d", i) + `">
          <input type="hidden" name="action" value="delete">
          <button type="submit" onclick="return confirm('Delete proxy?');">Delete</button>
        </form>
      </td>
    </tr>`
	}
	html += `</table>
</body>
</html>`
	w.Write([]byte(html))
}

func addCookiesHandler(w http.ResponseWriter, r *http.Request) {
	outputPath := filepath.Join("..", "datacenter", "cookies.json")
	var cookies []Cookies

	// Load existing cookies.json if present
	if data, err := ioutil.ReadFile(outputPath); err == nil {
		err = json.Unmarshal(data, &cookies)
		if err != nil {
			http.Error(w, "Error parsing existing JSON", http.StatusInternalServerError)
			return
		}
	}

	if r.Method == http.MethodPost {
		// Parse form values
		if err := r.ParseForm(); err != nil {
			http.Error(w, "Failed to parse form", http.StatusBadRequest)
			return
		}

		action := r.FormValue("action")
		switch action {
		case "add", "edit":
			// Update both fields
			authToken := strings.TrimSpace(r.FormValue("auth_token"))
			ct0 := strings.TrimSpace(r.FormValue("ct0"))
			if authToken == "" || ct0 == "" {
				http.Error(w, "Both auth_token and ct0 are required", http.StatusBadRequest)
				return
			}
			cookies = append(cookies, Cookies{AuthToken: authToken, Ct0: ct0})

		case "delete":
			// Clear the JSON
			indexStr := r.FormValue("index")
			index, err := strconv.Atoi(indexStr)
			if err == nil && index >= 0 && index < len(cookies) {
				cookies = append(cookies[:index], cookies[index+1:]...)
			}
			//cookies = []Cookies{}

		default:
			http.Error(w, "Unknown action", http.StatusBadRequest)
			return
		}

		// Ensure directory exists
		os.MkdirAll(filepath.Dir(outputPath), os.ModePerm)

		// Write updated JSON
		file, err := os.Create(outputPath)
		if err != nil {
			http.Error(w, "Error updating file", http.StatusInternalServerError)
			return
		}
		defer file.Close()

		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(cookies); err != nil {
			http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
			return
		}

		// Redirect to refresh page
		http.Redirect(w, r, "/add-cookies", http.StatusSeeOther)
		return
	}

	// Render the HTML form
	// Render HTML form
	w.Header().Set("Content-Type", "text/html")
	html := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Manage Cookies Array</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    input[type="text"] { width: 400px; margin-bottom: 10px; }
    button { margin-top: 10px; padding: 6px 12px; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f2f2f2; }
    form.inline { display: inline; }
  </style>
</head>
<body>
  <h1>Manage Cookies Array JSON</h1>

  <h2>Add New Entry</h2>
  <form method="POST" action="/add-cookies">
    <div>
      <label for="auth_token">Auth Token:</label><br>
      <input type="text" id="auth_token" name="auth_token" required>
    </div>
    <div>
      <label for="ct0">ct0:</label><br>
      <input type="text" id="ct0" name="ct0" required>
    </div>
    <input type="hidden" name="action" value="add">
    <button type="submit">Add</button>
  </form>

  <h2>Current Entries</h2>
  <table>
    <tr><th>#</th><th>Auth Token</th><th>ct0</th><th>Actions</th></tr>` + renderRows(cookies) + `
  </table>
</body>
</html>`

	w.Write([]byte(html))
}
func renderRows(cookies []Cookies) string {
	rows := ""
	for i, c := range cookies {
		rows += fmt.Sprintf(`
<tr>
  <td>%d</td>
  <td><form method="POST" action="/add-cookies" class="inline">
      <input type="text" name="auth_token" value="%s" required>
      <input type="text" name="ct0" value="%s" required>
      <input type="hidden" name="index" value="%d">
      <input type="hidden" name="action" value="edit">
      <button type="submit">Update</button>
    </form></td>
  <td>
    <form method="POST" action="/add-cookies" class="inline">
      <input type="hidden" name="index" value="%d">
      <input type="hidden" name="action" value="delete">
      <button type="submit" onclick="return confirm('Delete this entry?');">Delete</button>
    </form>
  </td>
</tr>`, i, c.AuthToken, c.Ct0, i, i)
	}
	return rows
}

// Helper to preview JSON in the page
func toJSONPreview(c Cookies) string {
	data, _ := json.MarshalIndent(c, "", "  ")
	return string(data)
}

func addAddressHandler(w http.ResponseWriter, r *http.Request) {
	outputPath := filepath.Join("..", "addresses", "address.json")
	var addresses []Address
	if data, err := ioutil.ReadFile(outputPath); err == nil {
		json.Unmarshal(data, &addresses)
	}

	if r.Method == http.MethodPost {
		if err := r.ParseForm(); err != nil {
			http.Error(w, "Failed to parse form", http.StatusBadRequest)
			return
		}
		action := r.FormValue("action")
		switch action {
		case "add":
			newAddress := strings.TrimSpace(r.FormValue("newAddress"))
			newIndexStr := strings.TrimSpace(r.FormValue("newIndex"))
			if newAddress != "" && newIndexStr != "" {
				newIndex, err := strconv.ParseInt(newIndexStr, 10, 64)
				if err == nil {
					metadata, err := getTokenMetadataFromAPI(newAddress)
					if err != nil {
						metadata = &TokenMetadata{Name: "", Symbol: "", URI: ""}
					}
					now := time.Now().UTC()
					addresses = append(addresses, Address{
						Address:      newAddress,
						Name:         metadata.Name,
						Symbol:       metadata.Symbol,
						Index:        newIndex,
						AddedAt:      &now,
						LastActivity: &now,
					})
				}
			}
		case "edit":
			rowStr := r.FormValue("row")
			newAddress := strings.TrimSpace(r.FormValue("address"))
			newIndexStr := strings.TrimSpace(r.FormValue("index"))
			row, err := strconv.Atoi(rowStr)
			if err == nil && row >= 0 && row < len(addresses) && newAddress != "" && newIndexStr != "" {
				newIndex, err2 := strconv.ParseInt(newIndexStr, 10, 64)
				if err2 == nil {
					metadata, err3 := getTokenMetadataFromAPI(newAddress)
					if err3 != nil {
						metadata = &TokenMetadata{Name: "", Symbol: "", URI: ""}
					}
					now := time.Now().UTC()
					addresses[row] = Address{
						Address:      newAddress,
						Name:         metadata.Name,
						Symbol:       metadata.Symbol,
						Index:        newIndex,
						AddedAt:      &now,
						LastActivity: &now,
					}
				}
			}
		case "delete":
			rowStr := r.FormValue("row")
			row, err := strconv.Atoi(rowStr)
			if err == nil && row >= 0 && row < len(addresses) {
				addresses = append(addresses[:row], addresses[row+1:]...)
			}
		default:
			http.Error(w, "Unknown action", http.StatusBadRequest)
			return
		}
		os.MkdirAll(filepath.Dir(outputPath), os.ModePerm)
		file, err := os.Create(outputPath)
		if err != nil {
			http.Error(w, "Error updating file", http.StatusInternalServerError)
			return
		}
		defer file.Close()
		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "  ")
		if err := encoder.Encode(addresses); err != nil {
			http.Error(w, "Error encoding JSON", http.StatusInternalServerError)
			return
		}
		http.Redirect(w, r, "/add-address", http.StatusSeeOther)
		return
	}

	w.Header().Set("Content-Type", "text/html")
	html := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Manage Addresses</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    input[type="text"], input[type="number"] { width: 200px; padding: 5px; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background-color: #f2f2f2; }
    form.inline { display: inline; }
    button { margin: 2px; }
  </style>
</head>
<body>
  <h1>Manage Addresses</h1>
  <h2>Add New Address</h2>
  <form method="POST" action="/add-address">
    <label for="newAddress">Mint Address:</label>
    <input type="text" name="newAddress" required>
    <label for="newIndex">Index:</label>
    <input type="number" name="newIndex" required>
    <input type="hidden" name="action" value="add">
    <button type="submit">Add Address</button>
  </form>
  <h2>Current Addresses</h2>
  <table>
    <tr>
      <th>#</th>
      <th>Mint Address</th>
      <th>Name</th>
      <th>Symbol</th>
      <th>Index</th>
      <th>Actions</th>
    </tr>`
	for i, addr := range addresses {
		html += fmt.Sprintf(`<tr>
      <td>%d</td>
      <td>
        <form method="POST" action="/add-address" class="inline">
          <input type="text" name="address" value="%s" required>
      </td>
      <td>%s</td>
      <td>%s</td>
      <td>
          <input type="number" name="index" value="%d" required>
          <input type="hidden" name="row" value="%d">
          <input type="hidden" name="action" value="edit">
          <button type="submit">Update</button>
        </form>
      </td>
      <td>
        <form method="POST" action="/add-address" class="inline">
          <input type="hidden" name="row" value="%d">
          <input type="hidden" name="action" value="delete">
          <button type="submit" onclick="return confirm('Delete this address?');">Delete</button>
        </form>
      </td>
    </tr>`, i, addr.Address, addr.Name, addr.Symbol, addr.Index, i, i)
	}
	html += `</table>
</body>
</html>`
	w.Write([]byte(html))
}

type SessionStatus struct {
	ID      int    `json:"id"`
	Port    int    `json:"port"`
	Status  string `json:"status"`
	Updated string `json:"updated"`
}

func readSessionStatusHandler(w http.ResponseWriter, r *http.Request) {
	filePath := "../datacenter/activesession.json"
	var sessions []SessionStatus
	if _, err := os.Stat(filePath); err == nil {
		data, err := ioutil.ReadFile(filePath)
		if err != nil {
			http.Error(w, "Error reading session file", http.StatusInternalServerError)
			return
		}
		if err := json.Unmarshal(data, &sessions); err != nil {
			http.Error(w, "Error parsing session data", http.StatusInternalServerError)
			return
		}
	} else {
		sessions = []SessionStatus{}
	}

	w.Header().Set("Content-Type", "text/html")
	html := `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Active Sessions</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; }
    th { background-color: #f2f2f2; }
  </style>
</head>
<body>
  <h1>Active Sessions</h1>`
	if len(sessions) == 0 {
		html += `<p>No active sessions found.</p>`
	} else {
		html += `<table>
      <tr>
        <th>ID</th>
        <th>Port</th>
        <th>Status</th>
        <th>Updated</th>
      </tr>`
		for _, s := range sessions {
			html += fmt.Sprintf(`<tr>
        <td>%d</td>
        <td>%d</td>
        <td>%s</td>
        <td>%s</td>
      </tr>`, s.ID, s.Port, s.Status, s.Updated)
		}
		html += `</table>`
	}
	html += `
</body>
</html>`
	w.Write([]byte(html))
}

// ----------------------
// Middleware Helpers
// ----------------------

func setHeaders(w http.ResponseWriter) {
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set(contentTypeKey, contentTypeVal)
}

func withCORS(handler http.HandlerFunc) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}
		handler(w, r)
	}
}
func withCORSStat(handler http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
		if r.Method == http.MethodOptions {
			w.WriteHeader(http.StatusOK)
			return
		}
		handler.ServeHTTP(w, r)
	})
}

// Pool response structure
type PoolResponse struct {
	Data []struct {
		ID string `json:"id"`
	} `json:"data"`
}

// OHLCV structure (partial, based on your sample)
type OhlcvResponse struct {
	Data struct {
		ID         string `json:"id"`
		Type       string `json:"type"`
		Attributes struct {
			OhlcvList [][]float64 `json:"ohlcv_list"`
		} `json:"attributes"`
	} `json:"data"`
	Meta json.RawMessage `json:"meta"` // you can expand this if needed
}

func FetchAndSaveOhlcv() {

	addrFile := filepath.Join("..", "addresses", "address.json")

	// read and parse
	data, err := ioutil.ReadFile(addrFile)
	if err != nil {
		log.Printf("[holders] could not read addresses file: %v", err)
		return
	}
	var addrs []Address
	if err := json.Unmarshal(data, &addrs); err != nil {
		log.Printf("[holders] invalid JSON in addresses file: %v", err)
		return
	}

	//client := holders.NewBitqueryClient()
	//for _, a := range addrs {
	for i := len(addrs) - 1; i >= 0; i-- {
		a := addrs[i]
		if ExcludeAddrs[a.Address] {
			log.Printf("[holders] skipping excluded address: %s", a.Address)
			continue
		}
		fmt.Println("===== Getting ohlcv for",a.Address)
		// Step 1: Get pool ID
		poolUrl := fmt.Sprintf("https://api.geckoterminal.com/api/v2/networks/solana/tokens/%s/pools", a.Address)
		resp, err := http.Get(poolUrl)
		if err != nil || resp.StatusCode != http.StatusOK {
			log.Printf("[holders] failed to fetch pool data for %s: %v", a.Address, err)
			continue
		}
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)
		var poolData PoolResponse
		if err := json.Unmarshal(body, &poolData); err != nil || len(poolData.Data) == 0 {
			log.Printf("[holders] no pool data found for %s: %v", a.Address, err)
			continue
		}

		rawPoolID := poolData.Data[0].ID
		poolID := strings.TrimPrefix(rawPoolID, "solana_")

		// Step 2: Get OHLCV
		ohlcvUrl := fmt.Sprintf("https://api.geckoterminal.com/api/v2/networks/solana/pools/%s/ohlcv/minute?aggregate=1&limit=1000&currency=USD", poolID)
		ohlcvResp, err := http.Get(ohlcvUrl)
		if err != nil || ohlcvResp.StatusCode != http.StatusOK {
			log.Printf("[holders] failed to fetch OHLCV data for %s: %v", a.Address, err)
			continue
		}
		defer ohlcvResp.Body.Close()

		ohlcvBody, _ := io.ReadAll(ohlcvResp.Body)

		// Parse the new OHLCV data
		var newOhlcv OhlcvResponse
		if err := json.Unmarshal(ohlcvBody, &newOhlcv); err != nil {
			log.Printf("[holders] failed to parse OHLCV JSON for %s: %v", a.Address, err)
			continue
		}
		// Find the latest timestamp from the unsorted OHLCV list
/*		latestTs := float64(0)
		for _, ohlcv := range newOhlcv.Data.Attributes.OhlcvList {
			if len(ohlcv) > 0 && ohlcv[0] > latestTs {
				latestTs = ohlcv[0]
			}
		}

		if latestTs == 0 {
			log.Printf("[holders] no valid OHLCV timestamp found for %s", a.Address)
			ExcludeAddrs[a.Address] = true
			continue
		}

		// Compare latest OHLCV timestamp to current time
		latestTime := time.Unix(int64(latestTs), 0)
		if time.Since(latestTime) > 2*time.Hour {
			log.Printf("[holders] OHLCV data for %s is stale (last: %v), excluding", a.Address, latestTime)
			ExcludeAddrs[a.Address] = true
			continue
		}
*/
		// Add poolID to meta data
		// First, parse the current meta data
		var metaData map[string]interface{}
		if err := json.Unmarshal(newOhlcv.Meta, &metaData); err != nil {
			log.Printf("[holders] failed to parse meta data for %s: %v", a.Address, err)
			// Initialize empty meta if it doesn't exist or can't be parsed
			metaData = make(map[string]interface{})
		}

		// Add poolID to meta data
		metaData["poolID"] = poolID

		// Update the Meta field with the modified data including poolID
		updatedMeta, err := json.Marshal(metaData)
		if err != nil {
			log.Printf("[holders] failed to marshal updated meta data for %s: %v", a.Address, err)
		} else {
			newOhlcv.Meta = updatedMeta
		}

		// Step 3: Check if we already have data in Redis
		redisKey := fmt.Sprintf("ohlcv:%s", a.Address)
		existingData, err := RedisClient.Get(redisKey).Result()

		if err == nil {
			// Data exists, we need to merge
			var existingOhlcv OhlcvResponse
			if err := json.Unmarshal([]byte(existingData), &existingOhlcv); err != nil {
				log.Printf("[holders] failed to parse existing OHLCV JSON for %s: %v", a.Address, err)
				// If we can't parse existing data, just overwrite with new data
				newData, _ := json.Marshal(newOhlcv)
				RedisClient.Set(redisKey, newData, 0)
				continue
			}

			// Update the existing meta data with poolID
			var existingMetaData map[string]interface{}
			if err := json.Unmarshal(existingOhlcv.Meta, &existingMetaData); err != nil {
				// If we can't parse existing meta, initialize it
				existingMetaData = make(map[string]interface{})
			}

			// Add poolID to existing meta data
			existingMetaData["poolID"] = poolID

			// Update the Meta field with modified data
			updatedExistingMeta, err := json.Marshal(existingMetaData)
			if err != nil {
				log.Printf("[holders] failed to marshal updated existing meta data for %s: %v", a.Address, err)
			} else {
				existingOhlcv.Meta = updatedExistingMeta
			}

			// Create a map for existing data to filter out duplicates
			// We'll use timestamp (first element of each OHLCV array) as the key
			existingOhlcvMap := make(map[float64]bool)
			for _, ohlcv := range existingOhlcv.Data.Attributes.OhlcvList {
				if len(ohlcv) > 0 {
					existingOhlcvMap[ohlcv[0]] = true
				}
			}

			// Filter out duplicates from new data
			var uniqueNewOhlcv [][]float64
			for _, ohlcv := range newOhlcv.Data.Attributes.OhlcvList {
				if len(ohlcv) > 0 && !existingOhlcvMap[ohlcv[0]] {
					uniqueNewOhlcv = append(uniqueNewOhlcv, ohlcv)
				}
			}

			// Append unique new data to existing data
			existingOhlcv.Data.Attributes.OhlcvList = append(existingOhlcv.Data.Attributes.OhlcvList, uniqueNewOhlcv...)

// Sort OHLCV candles from oldest to newest based on timestamp (element 0)
			ohlcvList := existingOhlcv.Data.Attributes.OhlcvList
			sort.Slice(ohlcvList, func(i, j int) bool {
				return ohlcvList[i][0] < ohlcvList[j][0]
			})

			//fmt.Println("ohlcvList", ohlcvList)
			latestUnix := int64(ohlcvList[len(ohlcvList)-1][0])
			latestTime := time.Unix(latestUnix, 0)
			if time.Since(latestTime) > 20*time.Minute {
				log.Printf("[holders] DEAD coin: %s — latest candle is stale (last seen: %v)", a.Address, latestTime)
				ExcludeAddrs[a.Address] = true
				continue
			}

			if len(ohlcvList) >= 60 {
				latest30 := ohlcvList[len(ohlcvList)-60:]
				firstOpen := ohlcvList[0][1] // index 1 is open price
				//fmt.Println("First Open", firstOpen, "firstOpen*1.01", firstOpen*1.01)
				withinRange := true
				for _, candle := range latest30 {
					open := candle[1]
					if open > firstOpen*1.01 {
						withinRange = false
						break
					}
				}

				if withinRange {
					log.Printf("[holders] DEAD coin detected: %s — latest 30 candles within +1%% of %.9f", a.Address, firstOpen)
					ExcludeAddrs[a.Address] = true
					continue
				}
			}


			// Convert back to JSON
			mergedData, err := json.Marshal(existingOhlcv)
			if err != nil {
				log.Printf("[holders] failed to marshal merged OHLCV data for %s: %v", a.Address, err)
				continue
			}

			// Save back to Redis
			err = RedisClient.Set(redisKey, mergedData, 0).Err()
			if err != nil {
				log.Printf("[holders] failed to save merged OHLCV to Redis for %s: %v", a.Address, err)
			}
		} else if err == redis.Nil {
			// No existing data, just save new data with the updated meta containing poolID
			newData, _ := json.Marshal(newOhlcv)
			err = RedisClient.Set(redisKey, newData, 0).Err()
			if err != nil {
				log.Printf("[holders] failed to save new OHLCV to Redis for %s: %v", a.Address, err)
			}
		} else {
			// Some other Redis error
			log.Printf("[holders] Redis error when checking for existing OHLCV data for %s: %v", a.Address, err)
			// Try to save new data anyway with the updated meta
			newData, _ := json.Marshal(newOhlcv)
			RedisClient.Set(redisKey, newData, 0)
		}

		time.Sleep(6 * time.Second)
	}
}
/*
func fetchHoldersForAllAddresses() {
	// path to your addresses file
	addrFile := filepath.Join("..", "addresses", "address.json")

	// read and parse
	data, err := ioutil.ReadFile(addrFile)
	if err != nil {
		log.Printf("[holders] could not read addresses file: %v", err)
		return
	}
	var addrs []Address
	if err := json.Unmarshal(data, &addrs); err != nil {
		log.Printf("[holders] invalid JSON in addresses file: %v", err)
		return
	}

	client := holders.NewBitqueryClient()
	for _, a := range addrs {
		if ExcludeAddrs[a.Address] {
			log.Printf("[holders] skipping excluded address: %s", a.Address)
			continue
		}

		// get transfers for this mint/address
		fmt.Println("Getting Holder Info for", a.Address)
		output, err := client.UpdateAndGetTransfers(a.Address)
		if err != nil {
			log.Printf("[holders] error fetching for %s: %v", a.Address, err)
			continue
		}
		// optionally unmarshal and log length
		var transfers []Transfer
		if err := json.Unmarshal([]byte(output), &transfers); err != nil {
			log.Printf("[holders] invalid JSON for %s: %v", a.Address, err)
		} else {
			log.Printf("[holders] fetched %d transfers for %s", len(transfers), a.Address)
		}

		// store raw JSON in Redis under "holders:<mint>"
		/*
			key := fmt.Sprintf("holders:%s", a.Address)
			if err := RedisClient.Set(key, output, 0).Err(); err != nil {
				log.Printf("[holders] failed to save to Redis for %s: %v", a.Address, err)
			}*/
/*		key := fmt.Sprintf("holderhistory:%s", a.Address)

		// Check if the key exists
		exists, err := RedisClient.Exists(key).Result()
		if err != nil {
			log.Printf("[redis] error checking existence of key %s: %v", key, err)
			continue
		}

		var tokenData TokenData
		if exists == 0 {
			// Key does not exist, create new TokenData
			tokenData = TokenData{}
		} else {
			// Key exists, retrieve existing data
			res, err := RedisClient.Get(key).Result() //rh.JSONGet(key, ".")
			if err != nil {
				log.Printf("[redis] error getting JSON for key %s: %v", key, err)
				continue
			}
			if err := json.Unmarshal([]byte(res), &tokenData); err != nil {
				log.Printf("[json] error unmarshaling data for key %s: %v", key, err)
				continue
			}
		}

		for _, t := range transfers {
			// Find if holder already exists
			found := false
			for i, holder := range tokenData.Holders {
				if holder.Address == t.Address {
					// Append new amount and time
					tokenData.Holders[i].Amount = append(tokenData.Holders[i].Amount, t.Amount)
					tokenData.Holders[i].Time = append(tokenData.Holders[i].Time, time.Now().Format(time.RFC3339))
					found = true
					break
				}
			}
			if !found {
				// Add new holder
				newHolder := HolderData{
					Address: t.Address,
					Price:   t.Price,
					Amount:  []float64{t.Amount},
					Time:    []string{time.Now().Format(time.RFC3339)},
				}
				tokenData.Holders = append(tokenData.Holders, newHolder)
			}
		}

		// Set the updated TokenData back to Redis
		jsonData, err := json.Marshal(tokenData)
		if err != nil {
			log.Printf("failed to marshal snapshots to JSON: %v", err)
		}
		/*_, err = RedisClient.SET(key, ".", tokenData)
		if err != nil {
			log.Printf("[redis] error setting JSON for key %s: %v", key, err)
			continue
		}
		*/
/*		if err := RedisClient.Set(key, jsonData, 0).Err(); err != nil {
			log.Printf("failed to store snapshots in Redis: %v", err)
		}
		time.Sleep(6 * time.Second)
	}
}

// periodicHolderUpdater starts a ticker that fires every interval d.
func periodicHolderUpdater(d time.Duration) {
	fmt.Println("======== Getting Holders ============")
	ticker := time.NewTicker(d)
	defer ticker.Stop()

	// run once immediately

	fetchHoldersForAllAddresses()
	FetchAndSaveOhlcv()

	for range ticker.C {
		fetchHoldersForAllAddresses()
		FetchAndSaveOhlcv()
	}
}
*/


var (
	currentIndex int
	addressList  []Address
	mu           sync.RWMutex
)

func refreshAddressListLoop() {
	for {
		newAddrs := loadAddressesFromFile()
		mu.Lock()
		// Update addressList while keeping existing timestamps
		newMap := make(map[string]Address)
		for _, addr := range addressList {
			newMap[addr.Address] = addr
		}

		var updatedList []Address
		for _, a := range newAddrs {
			if existing, ok := newMap[a.Address]; ok {
				updatedList = append(updatedList, existing)
			} else {
				updatedList = append(updatedList, Address{Address: a.Address, LastActivity: &time.Time{}})
			}
		}
		addressList = updatedList
		mu.Unlock()
		time.Sleep(2 * time.Minute)
	}
}

// Load and parse JSON address file
func loadAddressesFromFile() []Address {
	addrFile := filepath.Join("..", "addresses", "address.json")
	data, err := ioutil.ReadFile(addrFile)
	if err != nil {
		log.Printf("Failed to read address file: %v", err)
		return nil
	}
	var addrs []Address
	if err := json.Unmarshal(data, &addrs); err != nil {
		log.Printf("Failed to parse address file: %v", err)
		return nil
	}
	return addrs
}
var fetchSem = make(chan struct{}, 5) // max 5 concurrent fetches

func safeFetch(addr Address) {
	fetchSem <- struct{}{} // acquire slot
	go func() {
		defer func() { <-fetchSem }() // release slot after completion
		fetchHoldersForAllAddresses(addr)
	}()
}

func calculateInterval(n int) time.Duration {
	if n <= 1 {
		return time.Minute
	}
	intervalSec := 60.0 / float64(n)
	if intervalSec < 3 {
		intervalSec = 3
	} else if intervalSec > 60 {
		intervalSec = 60
	}
	return time.Duration(intervalSec * float64(time.Second))
}

func startRateLimitedAddressUpdater() {
	go func() {
		var prevInterval time.Duration
		timer := time.NewTimer(time.Minute)
		defer timer.Stop()

		for {
			mu.Lock()
			n := len(addressList)
			mu.Unlock()

			interval := calculateInterval(n)
			if absDuration(interval - prevInterval) > 2*time.Second {
				if !timer.Stop() {
					<-timer.C
				}
				timer.Reset(interval)
				prevInterval = interval
				log.Printf("Updated interval: %v\n", interval)
			}

			select {
			case <-timer.C:
				mu.Lock()
				if len(addressList) == 0 {
					mu.Unlock()
					timer.Reset(interval)
					continue
				}

				// Find oldest address
				minIndex := 0
				oldest := *addressList[0].LastActivity
				for i := 1; i < len(addressList); i++ {
					if addressList[i].LastActivity.Before(oldest) {
						oldest = *addressList[i].LastActivity
						minIndex = i
					}
				}
				addr := addressList[minIndex]
				now := time.Now()
				addressList[minIndex].LastActivity = &now
				mu.Unlock()

				// Use safeFetch instead of spawning unbounded goroutines
				safeFetch(addr)

				timer.Reset(interval)
			}
		}
	}()
}

func absDuration(d time.Duration) time.Duration {
	if d < 0 {
		return -d
	}
	return d
}

/*
func startRateLimitedAddressUpdater() {
	ticker := time.NewTicker(3 * time.Second)
	for range ticker.C {
		mu.Lock()
		n := len(addressList)
		if n == 0 {
			mu.Unlock()
			continue
		}

		// Find the address with the oldest LastChecked timestamp
		minIndex := 0
		oldest_ := addressList[0].LastActivity
		oldest := *oldest_
		for i := 1; i < n; i++ {
			if addressList[i].LastActivity.Before(oldest) {
				oldest = *addressList[i].LastActivity
				minIndex = i
			}
		}

		addr := addressList[minIndex]
		now := time.Now()
		addressList[minIndex].LastActivity = &now
		mu.Unlock()

		go fetchHoldersForAllAddresses(addr)
	}
}
*/
func fetchHoldersForAllAddresses(a Address) {
	/*// path to your addresses file
	addrFile := filepath.Join("..", "addresses", "address.json")

	// read and parse
	data, err := ioutil.ReadFile(addrFile)
	if err != nil {
		log.Printf("[holders] could not read addresses file: %v", err)
		return
	}
	var addrs []Address
	if err := json.Unmarshal(data, &addrs); err != nil {
		log.Printf("[holders] invalid JSON in addresses file: %v", err)
		return
	}

	client := holders.NewBitqueryClient()
	for _, a := range addrs {*/
	//fmt.Println("==========   Getting Holder Info for", a.Address, "last", a.LastActivity)
	if ExcludeAddrs[a.Address] {
		log.Printf("[holders] skipping excluded address: %s", a.Address)
		//continue
	}
	fmt.Println("===Getting Holder Info for", a.Address, "last", a.LastActivity, "Excluded Address", ExcludeAddrs)
	client := holders.NewBitqueryClient()
	// get transfers for this mint/address
	fmt.Println("Getting Holder Info for", a.Address)
	output, err := client.UpdateAndGetTransfers(a.Address)
	if err != nil {
		log.Printf("[holders] error fetching for %s: %v", a.Address, err)
		//continue
	}
	// optionally unmarshal and log length
	var transfers []Transfer
	if err := json.Unmarshal([]byte(output), &transfers); err != nil {
		log.Printf("[holders] invalid JSON for %s: %v", a.Address, err)
	} else {
		log.Printf("[holders] fetched %d transfers for %s", len(transfers), a.Address)
	}

	// store raw JSON in Redis under "holders:<mint>"
	/*
		key := fmt.Sprintf("holders:%s", a.Address)
		if err := RedisClient.Set(key, output, 0).Err(); err != nil {
			log.Printf("[holders] failed to save to Redis for %s: %v", a.Address, err)
		}*/
	key := fmt.Sprintf("holderhistory:%s", a.Address)

	// Check if the key exists
	exists, err := RedisClient.Exists(key).Result()
	if err != nil {
		log.Printf("[redis] error checking existence of key %s: %v", key, err)
		//continue
	}

	var tokenData TokenData
	if exists == 0 {
		// Key does not exist, create new TokenData
		tokenData = TokenData{}
	} else {
		// Key exists, retrieve existing data
		res, err := RedisClient.Get(key).Result() //rh.JSONGet(key, ".")
		if err != nil {
			log.Printf("[redis] error getting JSON for key %s: %v", key, err)
			//continue
		}
		if err := json.Unmarshal([]byte(res), &tokenData); err != nil {
			log.Printf("[json] error unmarshaling data for key %s: %v", key, err)
			//continue
		}
	}

	for _, t := range transfers {
		// Find if holder already exists
		found := false
		for i, holder := range tokenData.Holders {
			if holder.Address == t.Address {
				// Append new amount and time
				tokenData.Holders[i].Amount = append(tokenData.Holders[i].Amount, t.Amount)
				tokenData.Holders[i].Time = append(tokenData.Holders[i].Time, time.Now().Format(time.RFC3339))
				found = true
				break
			}
		}
		if !found {
			// Add new holder
			newHolder := HolderData{
				Address: t.Address,
				Price:   t.Price,
				Amount:  []float64{t.Amount},
				Time:    []string{time.Now().Format(time.RFC3339)},
			}
			tokenData.Holders = append(tokenData.Holders, newHolder)
		}
	}

	// Set the updated TokenData back to Redis
	jsonData, err := json.Marshal(tokenData)
	if err != nil {
		log.Printf("failed to marshal snapshots to JSON: %v", err)
	}
	/*_, err = RedisClient.SET(key, ".", tokenData)
	if err != nil {
		log.Printf("[redis] error setting JSON for key %s: %v", key, err)
		continue
	}
	*/
	if err := RedisClient.Set(key, jsonData, 0).Err(); err != nil {
		log.Printf("failed to store snapshots in Redis: %v", err)
	}
	time.Sleep(6 * time.Second)
	//}
}

// periodicHolderUpdater starts a ticker that fires every interval d.
func periodicHolderUpdater(d time.Duration) {
	fmt.Println("======== Getting Holders ============")
	ticker := time.NewTicker(d)
	defer ticker.Stop()
	FetchAndSaveOhlcv()
	// run once immediately
	go refreshAddressListLoop() // Reload addresses every 2 mins
	go startRateLimitedAddressUpdater()
	//fetchHoldersForAllAddresses()
	fmt.Println("============ RERD ========")
	//FetchAndSaveOhlcv()
	//refreshAddressListLoop()
	for range ticker.C {
		//fetchHoldersForAllAddresses()
		FetchAndSaveOhlcv()
		//refreshAddressListLoop()
	}
}

type HolderSnapshot struct {
	Holders int    `json:"holders"`
	Time    string `json:"time"`
}

// getHolderSnapshotsHandler handles HTTP requests to retrieve holder snapshots.
func getHolderSnapshotsHandler(w http.ResponseWriter, r *http.Request) {
	// Extract the token address from query parameters
	tokenAddress := r.URL.Query().Get("address")
	if tokenAddress == "" {
		http.Error(w, "Missing 'address' query parameter", http.StatusBadRequest)
		return
	}

	// Construct the Redis key
	redisKey := fmt.Sprintf("token:%s:holdersplot", tokenAddress)

	// Retrieve the JSON array from Redis
	val, err := RedisClient.Get(redisKey).Result()
	if err == redis.Nil {
		http.Error(w, "No data found for the given address", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, fmt.Sprintf("Error retrieving data from Redis: %v", err), http.StatusInternalServerError)
		return
	}

	// Unmarshal the JSON array into a slice of HolderSnapshot
	var snapshots []HolderSnapshot
	if err := json.Unmarshal([]byte(val), &snapshots); err != nil {
		http.Error(w, fmt.Sprintf("Error unmarshaling JSON: %v", err), http.StatusInternalServerError)
		return
	}

	// Set response headers and write the JSON response
	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(snapshots); err != nil {
		http.Error(w, fmt.Sprintf("Error encoding JSON response: %v", err), http.StatusInternalServerError)
		return
	}
}
func notiFy() {
	// Create auth client
	auth := notity.NewTwitterCookieAuth(true, "https://185.236.95.42:6003:uyxzmtjn:ietipyjz5ls7", "")

	// Set cookies (these would need to be obtained from a browser or login process)
	cookies := map[string]string{
		"auth_token": "f9f0852d19d256ac472de5906a8bc19495ac3fcd",
		"ct0":        "f9ea021bf95dddddb05154a8437a4e49a192502307da1b39632e3709a171722fbf9bf5e224b215a6348d563e16a131b59822a48098e5729d01f30449c99d56a73b4424ef65873be347bc1c3002164687",
		// Add other required cookies
	}

	auth.SetCookies(cookies)

	// Create notification system
	//notifier := notity.NewNotificationSystem(auth, 3600) // Minimum 1 hour between notifications

	// Example address and metadata
	address := "0x123456789abcdef"
	symbol := "ETH"

	// In a real application, you'd have a monitoring loop
	//ctx := context.Background()
	addresses, err := notity.FetchAddresses("localhost") //fetchAddresses(hostname)
	if err != nil {
		panic(err)
	}
	ticker := time.NewTicker(60 * time.Second) // time.NewTicker sets up a periodic ticker :contentReference[oaicite:8]{index=8}
	defer ticker.Stop()
	// Mock impressions data

	for range ticker.C {
		for _, addr := range addresses {
			//impressions, _ := notity.FetchAndProcessImpressions("localhost", addr.Address)
			fmt.Println("==== Impression====", addr, address, symbol)
		}
	}
	// Set threshold to trigger notification at 1000 new views
	/*sent, err := notifier.TriggerAlert(ctx, address, symbol, impressions, 1000)
	if err != nil {
		fmt.Printf("Error triggering alert: %v\n", err)
	} else if sent {
		fmt.Println("Alert notification sent successfully!")
	} else {
		fmt.Println("No alert triggered (threshold not met or too soon)")
	}*/
}
func getSavedOhlcvHandler(w http.ResponseWriter, r *http.Request) {
	// Allow only GET method
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// Parse query parameter
	poolId := r.URL.Query().Get("poolId")
	if poolId == "" {
		http.Error(w, "Missing poolId parameter", http.StatusBadRequest)
		return
	}

	// Redis key format
	redisKey := fmt.Sprintf("ohlcv:%s", poolId)

	// Fetch from Redis
	val, err := RedisClient.Get(redisKey).Result()
	if err == redis.Nil {
		http.Error(w, "No data found for this poolId", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, "Failed to retrieve data from Redis", http.StatusInternalServerError)
		return
	}

	// Set JSON header
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(val))
}

func getHolderHistoryHandler(w http.ResponseWriter, r *http.Request) {
	// Extract the token address from query parameters
	tokenAddress := r.URL.Query().Get("address")
	if tokenAddress == "" {
		http.Error(w, "Missing 'address' query parameter", http.StatusBadRequest)
		return
	}

	// Construct the Redis key for holder history
	redisKey := fmt.Sprintf("holderhistory:%s", tokenAddress)

	// Retrieve the JSON blob from Redis
	val, err := RedisClient.Get(redisKey).Result()
	if err == redis.Nil {
		http.Error(w, "No holder history found for the given address", http.StatusNotFound)
		return
	} else if err != nil {
		http.Error(w, fmt.Sprintf("Error retrieving data from Redis: %v", err), http.StatusInternalServerError)
		return
	}

	// Unmarshal into TokenData
	var tokenData TokenData
	if err := json.Unmarshal([]byte(val), &tokenData); err != nil {
		log.Printf("[json] error unmarshaling holder history for %s: %v", tokenAddress, err)
		http.Error(w, fmt.Sprintf("Error parsing data: %v", err), http.StatusInternalServerError)
		return
	}

	// Set response headers and write the JSON response
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type")

	// Encode and send
	if err := json.NewEncoder(w).Encode(tokenData); err != nil {
		http.Error(w, fmt.Sprintf("Error encoding JSON response: %v", err), http.StatusInternalServerError)
	}
}

// ----------------------
// Main Function
// ----------------------

func main() {
	// Start migration subscription in a goroutine.
	go subscribeMigration()
	go periodicHolderUpdater(2 * time.Minute)
	go notiFy()
	http.HandleFunc("/saveData", withCORS(saveDataHandler))
	http.HandleFunc("/tweet", withCORS(tweetHandler))
	http.HandleFunc("/tweeturl", withCORS(tweetURLHandler))
	http.HandleFunc("/api/token-metadata", withCORS(getTokenMetadata))
	http.HandleFunc("/fetch-data", withCORS(fetchKeysAndDataHandler))
	http.HandleFunc("/fetch-holders", withCORS(fetchHolderKeysAndDataHandler))
	http.HandleFunc("/add-proxies", withCORS(addProxiesHandler))
	http.HandleFunc("/add-cookies", withCORS(addCookiesHandler))
	http.HandleFunc("/add-address", withCORS(addAddressHandler))
	http.HandleFunc("/session-status", withCORS(readSessionStatusHandler))
	http.HandleFunc("/api/holder-history", withCORS(getHolderHistoryHandler))
	http.HandleFunc("/api/holder-snapshots", withCORS(getHolderSnapshotsHandler))
	http.HandleFunc("/get-ohlcv", withCORS(getSavedOhlcvHandler))
	staticPath := filepath.Join("..", "static")
	fs := http.FileServer(http.Dir(staticPath))
	http.Handle("/static/", withCORSStat(http.StripPrefix("/static/", fs)))

	addressPath := filepath.Join("..", "addresses")
	fs_addr := http.FileServer(http.Dir(addressPath))
	http.Handle("/addresses/", withCORSStat(http.StripPrefix("/addresses/", fs_addr)))

	slptokenPath := filepath.Join("..", "spltoken")
	fs_slptkn := http.FileServer(http.Dir(slptokenPath))
	http.Handle("/spltoken/", withCORSStat(http.StripPrefix("/spltoken/", fs_slptkn)))

	fmt.Println("Server running on http://localhost:3300")
	http.ListenAndServe(":3300", nil)
}
